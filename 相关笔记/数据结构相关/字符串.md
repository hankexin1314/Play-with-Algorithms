解题方法

- 数组记录字符上一次出现的位置/字符第一次出现的位置
- 双指针
- 哈希表

#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

#### [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

#### [205. *同构字符串(很好的例子)](https://leetcode-cn.com/problems/isomorphic-strings/)

- 最容易想到的哈希表实现映射

```java
public boolean isIsomorphic(String s, String t) {

    if(s == null || s.length() == 0) return true;
    HashMap<Character, Character> map = new HashMap<>(); // 存储映射信息
    HashSet<Character> used = new HashSet<>(); // 存储是否被映射过，避免两个字符映射到同一个字符
    for(int i = 0; i < s.length(); i++) { // 两个字符串长度相同
        char cs = s.charAt(i), ct = t.charAt(i);
        if(map.containsKey(cs)) {
            if(map.get(cs) != ct) return false;
        } 
        else {
            if(used.contains(ct)) return false;
            else {
                used.add(ct);
                map.put(cs, ct);
            }
        }
    }

    return true;
}
```

- HashMap是要将两个字符串的每一位之间建立一一对应的关系，并且存储起来，这是**直接建立联系**
- 另一种思路，间接建立联系，在两个字符串中间找到第三个变量，利用第三方**间接建立联系**
- 两种行的思路：字符第一次出现的位置，字符上一次出现的位置
- 字符第一次出现的位置 相当于 将`add`标记为`011` 将`egg`标记为`011`，然后比较二者是否相同。相当于为每一个字符找到了唯一对应的第三方，可优化，减少indexOf的计算次数
- 字符上一次出现的位置：与第一次出现的位置思路类似，但是效率更高。i + 1是为了与默认值0区分开

```java
public boolean isIsomorphic(String s, String t) {

    int[] preIndexOfS = new int[256];
    int[] preIndexOfT = new int[256];
    for (int i = 0; i < s.length(); i++) {

        char sc = s.charAt(i), tc = t.charAt(i);
        preIndexOfS[sc] = s.indexOf(sc); // 字符第一次出现的位置
        preIndexOfT[tc] = t.indexOf(tc);
        if (preIndexOfS[sc] != preIndexOfT[tc]) {
            return false;
        } 
    }
    return true;
}

public boolean isIsomorphic(String s, String t) {
    int[] preIndexOfS = new int[256];
    int[] preIndexOfT = new int[256];
    for (int i = 0; i < s.length(); i++) {
        char sc = s.charAt(i), tc = t.charAt(i);
        if (preIndexOfS[sc] != preIndexOfT[tc]) {
            return false;
        }
        preIndexOfS[sc] = i + 1; // 字符上一次出现的位置
        preIndexOfT[tc] = i + 1;
    }
    return true;
}
```

