### 二叉树的遍历——非递归

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```java
public List<Integer> preorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.addLast(root);
    while(!stack.isEmpty()) {
        TreeNode node = stack.removeLast();
        if(node == null) continue;
        res.add(node.val);
        stack.addLast(node.right);
        stack.addLast(node.left);
    }

    return res;
}

public List<Integer> preorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while(!stack.isEmpty() || cur != null) {
        while(cur != null) {
            res.add(cur.val);
            stack.addLast(cur);
            cur = cur.left;
        }
        cur = stack.removeLast();
        cur = cur.right;
    }

    return res;
}
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
public List<Integer> postorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode pre = null;
    while(!stack.isEmpty() || root != null) {
        while(root != null) {
            stack.addLast(root);
            root = root.left;
        }
        root = stack.peekLast();
        if(root.right == null || root.right == pre) {
            res.add(root.val);
            pre = root;
            stack.removeLast(); // pop
            root = null;
        }
        else
            root = root.right;
    }
    return res;
}

public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
public List<Integer> inorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    while(!stack.isEmpty() || root != null) {

        while(root != null) {
            stack.addLast(root);
            root = root.left;
        }
        root = stack.removeLast();
        res.add(root.val);
        root = root.right;
    }

    return res;
}
```

### 递归

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```java
boolean res;

public boolean isBalanced(TreeNode root) {
	res = true;
    depth(root);
    return res;
}

private int depth(TreeNode root) {
    
    if(root == null) return 0;
    int l = depth(root.left);
    int r = depth(root.right);
    if(Math.abs(l - r) > 1) res = false;
    return 1 + Math.max(l, r);
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

去除掉上一题的条件判断即可

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```java
int max;

public int diameterOfBinaryTree(TreeNode root) {
	max = 0;
    maxDepth(root);
    return max;
}

private int maxDepth(TreeNode root) {
    if(root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    max = Math.max(max, l + r);
    return Math.max(l, r) + 1;
}
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

#### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
HashMap<Integer, Integer> map;
public TreeNode buildTree(int[] preorder, int[] inorder) {

    map = new HashMap<>();
    for(int i = 0; i < inorder.length; i++) 
        map.put(inorder[i], i);
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

private TreeNode buildTree(int[] pre, int pl, int pr, int[] in, int il, int ir) {

    if(il > ir) return null;
    TreeNode root = new TreeNode(pre[pl]);
    if(il == ir) return root;
    int index = map.get(pre[pl]);
    root.left = buildTree(pre, pl + 1, pl + index - il, in, il, index - 1);
    root.right = buildTree(pre, pr - (ir - index) + 1, pr, in, index + 1, ir);

    return root;
}
```

#### [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

先寻找相等的节点，找到后判断是否为子结构

```java
public boolean isSubStructure(TreeNode A, TreeNode B) {

    if(A == null || B == null) return false;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(A);
    while(!queue.isEmpty()) {
        TreeNode node = queue.poll();
        if(node.val == B.val) {
            if(helper(node, B)) return true;
        }
        if(node.left != null) queue.offer(node.left);
        if(node.right != null) queue.offer(node.right);
    }

    return false;

}

// 判断 B 是否为 A（包含）的子结构
private boolean helper(TreeNode A, TreeNode B) {

    if(B == null) return true;
    if(A == null) return false;
    if(A.val != B.val) return false;
    else return helper(A.left, B.left) && helper(A.right, B.right);
}
```

#### [面试题37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

思路清晰 重点在于各种特殊情况的处理

```java
// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    if(root == null) return "[]";
    StringBuilder res = new StringBuilder("[");
    int count = 0; // 记录队列中非null节点的个数
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    count ++;
    while(!queue.isEmpty() && count != 0) {
        TreeNode node = queue.poll();
        if(node == null) {
            res.append("null,");
        }
        else {
            res.append(node.val);
            res.append(",");
            count --;
            queue.offer(node.left);
            if(node.left != null) count ++;
            queue.offer(node.right);
            if(node.right != null) count ++;
        }
    }
    res.setLength(res.length());
    res.append("]");
    return res.toString();
}

// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    data = data.substring(1, data.length() - 1);
    if(data.equals("")) return null;
    String[] ele = data.split(",");
    int index = 0;
    TreeNode root = strToNode(ele[index]);
    index ++;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty() && index < ele.length) {
        TreeNode node = queue.poll();
        if(node != null) {
            node.left = strToNode(ele[index]);
            queue.offer(node.left);
            index ++;
            node.right = index < ele.length ? strToNode(ele[index]): null;
            queue.offer(node.right);
            index ++;
        }
    }

    return root;
}

private TreeNode strToNode(String str) {
    if(str.equals("null")) return null;
    return new TreeNode(Integer.parseInt(str));
}
```

#### [面试题68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

利用大小关系寻找

#### [面试题68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

递归寻找

