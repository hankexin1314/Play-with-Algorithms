### 二叉树的遍历——非递归

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```java
public List<Integer> preorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    stack.addLast(root);
    while(!stack.isEmpty()) {
        TreeNode node = stack.removeLast();
        if(node == null) continue;
        res.add(node.val);
        stack.addLast(node.right);
        stack.addLast(node.left);
    }

    return res;
}

public List<Integer> preorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while(!stack.isEmpty() || cur != null) {
        while(cur != null) {
            res.add(cur.val);
            stack.addLast(cur);
            cur = cur.left;
        }
        cur = stack.removeLast();
        cur = cur.right;
    }

    return res;
}
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
public List<Integer> postorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode pre = null;
    while(!stack.isEmpty() || root != null) {
        while(root != null) {
            stack.addLast(root);
            root = root.left;
        }
        root = stack.peekLast();
        if(root.right == null || root.right == pre) {
            res.add(root.val);
            pre = root;
            stack.removeLast(); // pop
            root = null;
        }
        else
            root = root.right;
    }
    return res;
}

public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
public List<Integer> inorderTraversal(TreeNode root) {

    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    while(!stack.isEmpty() || root != null) {

        while(root != null) {
            stack.addLast(root);
            root = root.left;
        }
        root = stack.removeLast();
        res.add(root.val);
        root = root.right;
    }

    return res;
}
```

### 递归

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```java
boolean res;

public boolean isBalanced(TreeNode root) {
	res = true;
    depth(root);
    return res;
}

private int depth(TreeNode root) {
    
    if(root == null) return 0;
    int l = depth(root.left);
    int r = depth(root.right);
    if(Math.abs(l - r) > 1) res = false;
    return 1 + Math.max(l, r);
}
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

去除掉上一题的条件判断即可

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```java
int max;

public int diameterOfBinaryTree(TreeNode root) {
	max = 0;
    maxDepth(root);
    return max;
}

private int maxDepth(TreeNode root) {
    if(root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    max = Math.max(max, l + r);
    return Math.max(l, r) + 1;
}
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

#### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
HashMap<Integer, Integer> map;
public TreeNode buildTree(int[] preorder, int[] inorder) {

    map = new HashMap<>();
    for(int i = 0; i < inorder.length; i++) 
        map.put(inorder[i], i);
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

private TreeNode buildTree(int[] pre, int pl, int pr, int[] in, int il, int ir) {

    if(il > ir) return null;
    TreeNode root = new TreeNode(pre[pl]);
    if(il == ir) return root;
    int index = map.get(pre[pl]);
    root.left = buildTree(pre, pl + 1, pl + index - il, in, il, index - 1);
    root.right = buildTree(pre, pr - (ir - index) + 1, pr, in, index + 1, ir);

    return root;
}
```

#### [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

先寻找相等的节点，找到后判断是否为子结构

```java
public boolean isSubStructure(TreeNode A, TreeNode B) {

    if(A == null || B == null) return false;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(A);
    while(!queue.isEmpty()) {
        TreeNode node = queue.poll();
        if(node.val == B.val) {
            if(helper(node, B)) return true;
        }
        if(node.left != null) queue.offer(node.left);
        if(node.right != null) queue.offer(node.right);
    }

    return false;

}

// 判断 B 是否为 A（包含）的子结构
private boolean helper(TreeNode A, TreeNode B) {

    if(B == null) return true;
    if(A == null) return false;
    if(A.val != B.val) return false;
    else return helper(A.left, B.left) && helper(A.right, B.right);
}
```

#### [面试题37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

思路清晰 重点在于各种特殊情况的处理

```java
// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    if(root == null) return "[]";
    StringBuilder res = new StringBuilder("[");
    int count = 0; // 记录队列中非null节点的个数
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    count ++;
    while(!queue.isEmpty() && count != 0) {
        TreeNode node = queue.poll();
        if(node == null) {
            res.append("null,");
        }
        else {
            res.append(node.val);
            res.append(",");
            count --;
            queue.offer(node.left);
            if(node.left != null) count ++;
            queue.offer(node.right);
            if(node.right != null) count ++;
        }
    }
    res.setLength(res.length());
    res.append("]");
    return res.toString();
}

// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    data = data.substring(1, data.length() - 1);
    if(data.equals("")) return null;
    String[] ele = data.split(",");
    int index = 0;
    TreeNode root = strToNode(ele[index]);
    index ++;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty() && index < ele.length) {
        TreeNode node = queue.poll();
        if(node != null) {
            node.left = strToNode(ele[index]);
            queue.offer(node.left);
            index ++;
            node.right = index < ele.length ? strToNode(ele[index]): null;
            queue.offer(node.right);
            index ++;
        }
    }

    return root;
}

private TreeNode strToNode(String str) {
    if(str.equals("null")) return null;
    return new TreeNode(Integer.parseInt(str));
}
```

#### [面试题68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

利用大小关系寻找

#### [面试题68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

递归寻找

#### [面试题28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

刚开始不太会写，仔细思考，因为需要有两个指针，一个指向root左子树，一个指向root右子树

- 所以需要写一个有两个参数的递归
- 或者写一个有两个stack的非递归（两次BFS，左子树和右子树顺序不同）

```java
public boolean isSymmetric(TreeNode root) {

    if(root == null) return true;
    return helper(root.left, root.right);
}

private boolean helper(TreeNode left, TreeNode right) {

    if(left == null && right == null) return true;
    if(left == null || right == null) return false;
    if(left.val != right.val) return false;
    return helper(left.left, right.right) && helper(left.right, right.left);
}
```

#### [面试题32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

层序遍历

#### [面试题32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

加入一个参数记录这一行元素的个数即可

#### [面试题32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

调整入队顺序即可

#### [面试题34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```java
List<List<Integer>> res;
public List<List<Integer>> pathSum(TreeNode root, int sum) {

    res = new ArrayList<>();
    if(root == null) return res;
    helper(root, sum, new ArrayList<Integer>());

    return res;
}

private void helper(TreeNode root, int target, List<Integer> subRes) {

    subRes.add(root.val);
    target -= root.val;
    if(target == 0 && root.left == null && root.right == null)  
        res.add(new ArrayList<>(subRes));
    if(root.left != null) {
        helper(root.left, target, subRes);
        subRes.remove(subRes.size() - 1);
    }
    if(root.right != null) {
        helper(root.right, target, subRes);
        subRes.remove(subRes.size() - 1);
    }
}
```

#### [面试题54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

反向中序遍历 

递归，count必须为全局变量

```java
// 非递归
public int kthLargest(TreeNode root, int k) {

    TreeNode cur = root;
    Deque<TreeNode> stack = new LinkedList<>();
    int count = 0;
    while(!stack.isEmpty() || cur != null) {
        while(cur != null) {
            stack.addLast(cur);
            cur = cur.right;
        }
        cur = stack.removeLast();
        count ++;
        if(count == k) return cur.val;
        cur = cur.left;
    }

    throw new IllegalStateException();
}

// 递归
int res;
int count;
public int kthLargest(TreeNode root, int k) {
    count = 0;
    inorder(root, k);
    return res;
}

private void inorder(TreeNode root, int k) {

    if(root == null) return;
    inorder(root.right, k);
    count ++;
    if(count == k) {
        res = root.val;
        return;
    }
    else if(count > k) return;
    inorder(root.left, k);
}
```

#### [面试题33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

```java
public boolean verifyPostorder(int[] postorder) {

    if(postorder == null) return false;
    return postOrder(postorder, 0, postorder.length - 1);
}

// 后序遍历的结果为[start, end]，返回是否可以拼成一个二叉搜索树
private boolean postOrder(int[] postorder, int start, int end) {

    if(start >= end) return true;
    int root = postorder[end];
    int index = start; // 寻找第一个 >= root的值的下标
    for(; index < end; index++) {
        if(postorder[index] > root)
            break;
    }
    for(int i = index + 1; i < end; i++) {
        if(postorder[i] < root)
            return false;
    }

    return postOrder(postorder, start, index - 1) && postOrder(postorder, index, end - 1);
}
```

