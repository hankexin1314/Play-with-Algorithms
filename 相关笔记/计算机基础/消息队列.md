## 一、为什么用消息队列

异步、解耦、削峰

### 1. 异步

- 下单之后，可能需要进行很多环节，比如创建订单，写入订单，减库存， 支付，然后结束，以后扩展可能还有优惠券，积分，短信通知之类的功能
- 用户点击下单后，需要**等待很久**（等订单创建完，优惠券判断完，积分加完，短信通知完），才显示支付完成，体验极差

- 使用消息队列，可以异步下单，下单，支付，然后其他环节**监听消息队列**，得到支付成功的消息，可以**同时去执行**
- 如果后续扩展，则直接订阅消息即可

> 为什么不用线程，线程池来实现？

### 2. 解耦

> 为什么不用线程池，多线程来实现？

- 每次新增功能都需要调用一个接口，然后还需要重新发布系统，耦合度高，问题排查也麻烦
- 使用消息队列，新增的环节直接监听消息队列即可

> 如何保证其他业务也成功？

- **分布式事务**

### 3. 削峰

- 服务器能处理多少，就消费多少，可能处理慢一些但是不至于服务器挂掉，等流量高峰过去服务器就没问题了

- 给一个好的提示页面即可

## 二、基本概念

### 1. 常见模型

#### 1.1 队列模型（RabbitMQ）

![640 (4)](E:\workspace\Play-with-Algorithms\img\640 (4).png)

- 一人生产，多人竞争

#### 1.2 发布/订阅模型（RocketMQ/Kafka）

![640 (5)](E:\workspace\Play-with-Algorithms\img\640 (5).png)

- 一人生产，多人接收

> RabbitMQ就是利用Exchange来将一个消息发到多个队列

### 2. 基本概念

![640 (6)](E:\workspace\Play-with-Algorithms\img\640 (6).png)

- **Broker**：消息队列服务端

> - 消费者从Broker中取或者Broker主动推送给消费者

- 发布订阅模型一个**主题**下有多个**队列**，通过**轮询**或者**Hash取余**来将同一个主题的消息分配到不同的队列
- 消费组

![640 (7)](E:\workspace\Play-with-Algorithms\img\640 (7).png)

## 三、可能出现的问题以及解决

- 重复消费，消息丢失，顺序消费，系统维护成本
- 数据一致性（其他服务，比如优惠券，万一失败怎么办）
- 可用性（万一挂了怎么办）

### 1. 重复消费

#### 1.1 原因

- 多个功能监听下单成功的消息，比如优惠券，积分，库存等
- 下游功能一般有**重试机制**，如果下游业务异常，会抛出异常然后要求你**重新发送一次**

- 但是别的服务也在监听，可能会造成重复加积分，重复减库存，**重复消费**等问题

> - 发送消息要等到Broker的响应，如果响应因为网络原因没收到，就**重新发送**
>
> - 一个消费者消费完本条消息，本来该更新offset去拿下一个消息了，但是它挂了，重新上线后，offset还未更新，就又执行了一次

#### 1.2 解决

- 重复消费无法避免，只能使用别的方法解决

- **幂等**：无论执行多少次，结果都一样，同样的参数调用这个接口，调用多少次结果都一样
- 分场景考虑，**重要场景**，比如和金钱相关就**强校验**，不是很重要的场景，比如发送短信验证码就**弱校验**
- **强校验**：比如双十一，用**业务场景 + 订单号唯一标识**进行**前置条件判断**，或者**数据库唯一键**，或者在**查询语句**上做限制
- **弱校验**：可以使用将**唯一标识**作为key放到redis中，即使redis消息过期，因为不是重要场景也无所谓

### 2. 消息丢失

![640 (8)](E:\workspace\Play-with-Algorithms\img\640 (8).png)

- 生产者要妥善处理Broker的响应，重复发送，多次失败报警之类的
- Broker 开启持久化，在消息成功**刷盘**后再给生产者响应，集群，多点部署
- 消费者消费完要返回合理的响应给Broker

### 3. 顺序消费

**全局有序**：一个Topic只能有一个队列

**部分有序**：将这部分操作都发送到同一个队列

- 一般需要顺序消费都是同一场景下，比如下单，支付，减库存，生成订单这种
- 同一场景下的几个不同操作同时发过去顺序变动
- 可以使用**Hash取余**将同一场景下的操作分配到**同一个队列**中，这样就可以保证**发送方有序**，具体是否有序执行还要看消费者是否**顺序消费**

### 4. 分布式事务

- **为什么要用**:可能下单流程涉及很多环节，优惠券，积分等，如何保证大家都成功呢？——分布式事务

- **缺点**：长时间锁定数据库资源，导致响应不快，并发低。网络抖动导致数据不一致等

### 5. 消息堆积

- 首先确定原因——消费能力不行？BUG？
- 如果该优化都优化了还是堆积，只能水平扩容，增加该Topic下的队列数和消费者数量（消费者增加队列数也要增加，不然没得消费）

## 四、技术选型

![640 (1)](E:\workspace\Play-with-Algorithms\img\640 (1).webp)

- RabbitMQ相比于后两个，主要劣势在于后两个**天生分布式架构**，**高可用**，**数据多副本**，而且**单机吞吐量**都是**10w级**，RabbitMQ只有**万级**
- RabbitMQ的主要优势在于**响应时间**是**微秒级**，后两个都是**毫秒级**

