## 概述

### 一、什么是操作系统

- 操作系统本质是一个计算机程序，作用是管理计算机的硬件和软件资源。
- 特征： 并发，共享，虚拟，异步
- 基本功能：进程管理，内存管理，文件管理，设备管理

### 二、系统调用

操作系统为了安全考虑，将系统分为用户态和内核态，区别主要是能访问的资源不同，一个用户态进程，需要使用内核态的方法，就需要系统调用，由操作系统代为完成。

- 文件读写 open read write
- 信息维护 sleep， getpid， alarm（定时器）

### 三、大内核和微内核

- 大内核就是将所有功能放入内核，性能高
- 微内核是因为操作系统不断复杂，所以将其分为多个模块，只有一个很小的模块在内核，其他都在用户态，需要频繁在用户态和核心态之间切换，性能差

## 进程管理

### 一、进程和线程

- （资源分配）进程是资源分配的基本单位，线程不拥有资源，但是可以访问进程中的资源
- （调度）线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源。进行同一个进程中的线程切换时，不会造成进程切换
- （开销）系统创建或者撤销进程时，需要分配，回收资源，设置cpu状态等，开销远大于创建和撤销线程的开销
- （通信）线程间的通信通过直接读写进程的数据实现，进程间的通信则比较复杂

### 二、进程的状态

- 状态为：创建，就绪，运行，阻塞，结束

- **就绪**和**运行**和相互转换，转换原因是cpu时间片的分配和耗尽
- **阻塞**是由**运行**转换而来，缺乏资源（不包括cpu时间片），资源到位后转化为**就绪**

### 三、进程调度

#### 1. 批处理系统

没有太多的用户，保证吞吐量

- FCFS 先来先服务，利于长作业，不利于短作业，短作业必须等待长作业执行完

- SJF(short job first) 短作业优先，长作业可能一直等待，被饿死

- 高响应比优先： 兼顾长短作业
  $$
  (等待时间 + 要求服务时间)/要求服务时间
  $$
  

#### 2. 交互式系统

大量用户交互操作，需要快速响应

- 时间片轮转： 按FCFS排队，然后时间片依次分配。受时间片大小影响，时间片太大，实时性不好；太小则切换频繁，效率低

- 优先级调度：为了避免优先级低的饿死，会随时间推移提高进程优先级
- 多级反馈队列：设置多个队列，优先级递减，时间片递增，例如1248。一个进程进来，放进第1队列末尾（优先级最高，时间片最短），如果没执行完，则放进第2队列末尾...只有第1队列为空时才会执行第2队列进程。

#### 3.实时系统

需要在一个确定时间内得到响应

### 四、 进程同步

#### 1. 概念

- 临界区：访问临界资源的代码

- 同步：进程之间因合作而产生的制约，二者需要有先后执行关系
- 互斥：同一时刻只能有一个进程进入临界区

#### 2. 进程实现同步互斥的方法

- 信号量（PV操作） 

#### 3. 线程间同步的方式

- 信号量（可以是非负整数）
- 互斥量（只能为0/1）（Lock锁，synchronized等）
- 事件，这个事件完成后唤醒下一个事件来实现同步

#### 3. 经典同步问题

- 生产者消费者
- 哲学家进餐
- 读者写者

### 五、进程通信

#### 1. 同步和通信

- 同步：控制多个进程按一定顺序执行
- 通信： 进程之间传递信息

#### 2. 方法（6种）

##### 2.1 管道

- 本质是内核缓冲区（**内存**中），进程以FIFO的方式存取数据。缓冲区满或者缓冲区空，存取时会阻塞，等待缓冲区空或者新数据到来后再唤醒。

- 数据读一次后就不存在了
- 只支持半双工（单向数据流），如果要双向需要两条管道
- 只能用于父子和兄弟进程之间
- 传递的是无格式字节流，需要提前约定好数据格式

##### 2.2 命名管道

- 关联了进程的路径名，名字以文件形式存在**文件系统**中，从而可以在非亲缘进程之间通信，内容存放在**内存**中
- 因为通过路径名访问，需要确定对方存在，否则阻塞
- 严格遵循FIFO

##### 2.3 消息队列

- 存放在**内核**中的消息链表，只有操作系统重启才会删除消息队列
- 允许一个或多个进程对它读写消息
- 不一定FIFO，也可以实现随机查询
- 存放的有格式的消息，而不是无格式字节流

##### 2.4 信号量

- 计数器，用于多进程对临界资源的访问

##### 2.5 共享内存

- 多个进程直接读写同一块内存，**最快**的通信方式

##### 2.6 套接字

- 不同机器间的双向进程通信
- 由域，端口号，和协议类型。域分为，文件系统和Internet网络，指通信中的网络介质



## 死锁

### 一、死锁产生的必要条件

- 互斥：资源要么分配给一个进程，要么是可用的
- 占有和等待：已经得到资源的进程可以请求新的资源
- 不可剥夺：进程占有的资源不会被其他进程强制剥夺，只能被主动释放
- 循环等待：两个或以上进程组成环路，环路中的进程等待下一个进程所占有的资源

### 二、处理方法

#### 1. 鸵鸟策略

- 解决死锁问题的代价很高，而且死锁对用户影响不大，概率较低
- 所以主流操作系统都是无视死锁

#### 2. 死锁检测与死锁恢复

- 检测：对于单一资源类型，在有向图中DFS，有环路就说明发生死锁。对于多资源，则利用矩阵计算（类似银行家算法）。
- 恢复：抢占，回滚，杀死进程

#### 3. 死锁预防

在程序执行前就破坏产生死锁的必要条件。

- 破坏互斥：让所有资源都可共享使用，局限太大
- 破坏占有等待：开始时直接给进程他所需要的所有的数据，局限大
- 破坏不可剥夺
- 破坏循环等待：资源必须按序号递增分配。循环等待是因为A请求的资源被B占用，只要让资源必须按序号递增调用，则A请求资源10，B不可能在A之前占用资源10。局限大，有些进程不按序使用资源，造成资源浪费，也很难增添新设备。

#### 4. 死锁避免

- 在程序执行时，避免程序进入不安全状态——有可能发生死锁的状态，不安全不是一定会发生死锁，安全则是一定不会发生死锁。
- 系统性能好
- 银行家算法。进程执行前就声明运行时所需资源的最大的数量Max，当其在运行时申请资源时，计算其所拥有的Has和所申请的Want资源 Has + Want > Max，如果超过Max，则拒绝分配。

## 内存管理

### 一、虚拟内存

#### 1. 为什么要引入虚拟内存

两个原因：传统存储管理方式的局限性和局部性原理

- 传统存储管理方式：1.需要一次性将作业放入内存，作业过大无法装入内存时则无法执行，大量作业运行时，内存无法装下所有作业，造成效率降低。2.装入内存的作业直到作业执行完毕才会释放内存，即使因为IO阻塞等原因长期等待，也会占用内存。造成了内存资源极大浪费，效率还低下。
- 局部性原理：1. 空间，当程序访问了某个存储单元，它大概率会在近期访问其周围存储单元（数据很多以数组之类的数据结构存储着）；2. 时间，某一条指令执行后，不久后该指令很可能再次执行（循环操作）。

这两个原因得出结论，并不需要将全部数据指令放入内存，根据局部性原理只放入一部分进入内存也不会对程序执行造成太大影响，基于此，设计出了虚拟内存。

