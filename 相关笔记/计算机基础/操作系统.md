# 概述

## 一、什么是操作系统

- 操作系统本质是一个计算机程序，作用是管理计算机的硬件和软件资源，为用户提供一个和计算机交互的界面。
- 特征： 并发，共享，异步，虚拟
- 基本功能：进程管理，内存管理，文件管理，设备管理

> 并发与并行区分
>
> 互斥共享和同时共享
>
> 走走停停
>
> 时分复用（并发），空分复用（虚拟内存）

## 二、系统调用

操作系统为了安全考虑，将系统分为用户态和内核态，区别主要是能访问的资源不同，内核态可以访问任何资源，一个用户态进程，需要使用内核态的方法，就需要系统调用，由操作系统代为完成。

- 文件读写 open read write
- 信息维护 sleep， getpid， alarm（定时器）

## 三、大内核和微内核

- 大内核就是将所有功能放入内核，性能高
- 微内核是因为操作系统不断复杂，所以将其分为多个模块，只有一个很小的模块在内核，其他都在用户态，需要频繁在用户态和核心态之间切换，性能差

# 进程管理

## 一、进程和线程的区别

- **资源分配**：进程是资源分配的基本单位，线程不拥有资源，但是可以访问进程中的资源
- **调度**：线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源。进行同一个进程中的线程切换时，不会造成进程切换
- **开销**：系统创建或者撤销进程时，需要分配，回收资源，设置和保存cpu状态等，开销远大于创建和撤销线程的开销，线程仅需要保存和设置少量寄存器内容
- **通信**：线程间的通信通过直接读写进程的数据实现，进程间的通信则比较复杂

## 二、进程调度

### 1. 进程的状态

- **创建**：正在被创建

- **就绪**：获得了除了CPU时间片之外的所有资源
- **运行**：获得CPU时间片
- **阻塞**：也称**等待状态**，等待资源（除CPU时间片）
- **挂起**：因为虚拟内存，如果需要使用的空间没映射到物理内存就会挂起
- **结束**：

> 区别于线程的状态  等待和阻塞是分开的

#### 1.1 状态切换

- **就绪**和**运行**和相互转换，转换原因是cpu时间片的分配和耗尽
- **阻塞**是由**运行**转换而来，缺乏资源（不包括cpu时间片），资源到位后转化为**就绪**
- **就绪挂起**和**阻塞挂起**两个状态，会在所缺页进入内存后转为**就绪**或者**阻塞**状态

### 2. 调度算法

#### 2.1. 批处理系统

没有太多的用户，保证吞吐量

- **FCFS**：利于长作业，不利于短作业，短作业必须等待长作业执行完

- **SJF**(short job first) 短作业优先：长作业可能一直等待，被饿死

- **高响应比优先**： 兼顾长短作业
  $$
  (等待时间 + 要求服务时间)/要求服务时间
  $$
  

#### 2.2. 交互式系统

大量用户交互操作，需要快速响应

- **时间片轮转**： 按FCFS排队，然后时间片依次分配。受时间片大小影响，时间片太大，实时性不好；太小则切换频繁，效率低

- **优先级调度**：为了避免优先级低的饿死，会随时间推移提高进程优先级
- **多级反馈队列**：设置多个队列，优先级递减，时间片递增，例如1248。一个进程进来，放进第1队列末尾（优先级最高，时间片最短），如果没执行完，则放进第2队列末尾...只有第1队列为空时才会执行第2队列进程。

#### 2.3.实时系统

需要在一个确定时间内得到响应，一般是**可剥夺式**的调用

## 三、进程同步

### 1. 概念

- 临界区：访问临界资源的代码

- 同步：两个或多个共享关键资源的进程并发执行，应该同步进程避免使用资源冲突，使其按一定顺序执行
- 互斥：同一时刻只能有一个进程进入临界区

### 2. 进程实现同步互斥的方法

- 信号量（PV操作） 

### 3. 线程间同步的方式

- 信号量（可以是非负整数）
- 互斥量（只能为0/1）（Lock锁，synchronized等）
- 事件（wait/notify），这个事件完成后唤醒下一个事件来实现同步

### 3. 经典同步问题

- 生产者消费者
- 哲学家进餐
- 读者写者

## 四、进程通信

### 1. 管道

- 本质是**内核缓冲**（**内存**中），进程以FIFO的方式存取数据。缓冲区满或者缓冲区空，存取时会阻塞，等待缓冲区空或者新数据到来后再唤醒。
- 数据读一次后就不存在了
- 只支持半双工（单向数据流），如果要双向需要两条管道
- 只能用于父子和兄弟进程之间

>  ps auxf | grep mysql 一条linux命令
>
> `|`就是一个**管道**，将前一条指令的输出作为后一个指令的输入，**匿名管道**

### 2. 命名管道

- 关联了进程的**路径名**，从而可以在**非亲缘**进程之间通信
- 因为通过路径名访问，需要确定对方存在，否则阻塞
- 严格遵循FIFO

### 3. 消息队列

- 存放在**内核**中的消息链表，只有操作系统重启才会删除消息队列
- 允许一个或多个进程对它读写消息
- 不一定FIFO，也可以实现随机查询
- 存放的有格式的消息，而不是无格式字节流

### 4. 信号量

- 计数器，用于多进程对临界资源的访问

### 5. 共享内存

- 多个进程直接读写同一块内存，**最快**的通信方式

### 6. 套接字

- 不同机器间的双向进程通信
- 端口号，和协议类型组成



## 五、死锁

### 一、死锁产生的必要条件

- **互斥**：资源要么分配给一个进程，要么是可用的
- **占有和等待**：已经得到资源的进程可以请求新的资源
- **不可剥夺**：进程占有的资源不会被其他进程强制剥夺，只能被主动释放
- **循环等待**：两个或以上进程组成环路，环路中的进程等待下一个进程所占有的资源

### 二、处理方法

#### 1. 死锁预防

在程序执行前就破坏产生死锁的必要条件。

- 破坏互斥：让所有资源都可共享使用，局限太大
- 破坏占有等待：开始时直接给进程他所需要的所有的数据，局限大
- 破坏不可剥夺
- 破坏循环等待：资源必须按序号递增分配。循环等待是因为A请求的资源被B占用，只要让资源必须按序号递增调用，则A请求资源10，B不可能在A之前占用资源10。局限大，有些进程不按序使用资源，造成资源浪费，也很难增添新设备。

#### 2. 死锁避免

- 在程序执行时，避免程序进入**不安全状态**——有可能发生死锁的状态，不安全不是一定会发生死锁，安全则是一定不会发生死锁。
- 系统性能好
- **银行家算法**。进程执行前就声明运行时所需资源的最大的数量Max，当其在运行时申请资源时，计算其所拥有的Has和所申请的Want资源 Has + Want > Max，如果超过Max，则拒绝分配。

#### 3. 鸵鸟策略

- 解决死锁问题的代价很高，而且死锁对用户影响不大，概率较低
- 所以主流操作系统都是无视死锁

#### 4. 死锁检测与死锁恢复

- 检测：对于单一资源类型，在有向图中DFS，有环路就说明发生死锁。对于多资源，则利用矩阵计算（类似银行家算法）。
- 恢复：**抢占**，**回滚**，**杀死进程**

# 内存管理

## 一、概述

### 1. 内存管理主要功能

- 分配和回收物理内存
- 物理地址和逻辑地址的转换
- 内存扩充（虚拟内存）

### 2. 内存管理方式

#### 2.1 连续分配管理方式

- 单一连续分配：内存中只有一个进程
- 固定分区分配：将内存分为固定大小的块，一个块一个进程。局限：过大的进程放不进去，过小的进程浪费内存空间（内部碎片）
- 动态分区分配：依次紧贴放入进程，要多大内存就分配多大内存（外部碎片）

#### 2.2 非连续分配管理方式

##### 2.2.1 分页存储管理方式

连续分配弊端较多，所以采用非连续。

- 将内存分为等大小的**页框**，**页框**要比固定分区的块小很多，以**页框**为基本分配单位
- 将程序分为等大小的**页**，和**页框**一样大，操作系统为每个程序分配一定数目的**页框**
- 逻辑地址：我们编程时，操作系统分配的地址，逻辑地址一般大于物理地址（虚拟内存）
- 物理地址：内存中实际地址，二者需要一个映射关系。

> 如何将程序中的逻辑地址映射为内存中的物理地址呢？

- 例如对于一个32位的逻辑地址，我们要将它映射为31位的物理地址。我们将其分为两部分，20:12，左边称为页号，右边称为页内偏移（名字不重要）

| 逻辑地址 |            |
| -------- | ---------- |
| 页号     | 页内偏移量 |



- 页，页框大小为 2^12B = 4KB（地址空间12位，所以这么大）
- 内存中存有一个页表（可以理解为一个数组），index就是**页**号，value就是**页框**号（内存基本单位），页框号为19位（栗子），页表要求连续的空间
- 我们有逻辑地址后，分离出**页**号，在页表中找到**页框**号，然后`页框号 + 页内偏移 = 31位` 物理地址
- 访问两次内存，一次访问页表，另一次访问内存中的物理地址

> 如何减小访问两次内存带来的负面影响呢？

- 快表——存在高速缓存中
- 利用局部性原理维护一个快表，内容和页表类似，每次映射先看快表是否匹配，不匹配再去找页表（也称慢表）
- 快表中的内容会按一定规则交换的

> 隐藏的危机——页表过大，连续存储

- 页表项（也就是数组中的value）的大小，页号占20位，数组最大为2^20，为了全部表示，页表项最少20位，也就是最少3B，按4B来算
- 如果全部映射，页表大小 2^20 * 4B = 4MB 1024个页框
- 如果部分映射，对于40MB的程序 40MB / 4KB * 4B = 40KB ,10个页框，降低了效率（一个程序一个页表）
- 页表要求**连续存储**，连续的10个页框或者1024个页框都很难实现

> 解决办法

- 二级页表，逻辑地址分为三部分 10:10:12 ——一级页号，二级页号，页内偏移（一级页表大小不超过1个页框 4KB，也就4KB / 4B = 1K页表项，最多10位）

- 一级页表根据一级页号找二级页表，二级页表根据二级页号找页框号，两级页表大小都不超过1页大小
- 不用存无用的页表项，而且也不再要求多个连续页的空间

> 可能发生的越界

- 页号超过页表长度
- 页内不可能越界

##### 2.2.2 分段存储管理方式

- 分页是从计算机角度考虑，提高内存利用率，提升性能，无任何实际意义。分段是从程序员角度考虑，方便编程，一个程序一个段表。程序可分为主程序，子程序，堆栈，数组都可以单独成为一段

| 逻辑地址 |            |
| -------- | ---------- |
| 段号     | 段内偏移量 |

| 数组的index | 段表 |                      |
| ----------- | ---- | -------------------- |
| 段号        | 段长 | 本段在主存的初始地址 |

- 不可修改的代码和数据可共享，可修改的代码数据不可共享，通过指向同一个物理副本实现。

> 可能发生的越界

- 段号超过段表长度
- 段内偏移超过段长

##### 2.2.3 段页管理方式

- 页式可以有效利用资源，段式方便编程，利于共享，将二者结合
- 程序先分段，然后每一段分页，每个程序**一张**段表，**每个分段**有一张页表

| 逻辑地址 |      |            |
| -------- | ---- | ---------- |
| 段号     | 页号 | 页内偏移量 |

| index | 段表     |              |
| ----- | -------- | ------------ |
| 段号  | 页表长度 | 页表起始地址 |

- 段表找页表起始地址，页表找**页框**号，到物理地址

##### 2.2.4 总结

- 分页和分段都是为了提高内存利用率，减少内存碎片
- 分页和分段都是离散存储，页内和段内是连续的
- 页大小固定，由操作系统决定，段大小不固定，由程序决定。
- 分页仅仅是为了满足操作系统管理需要，分段是为了编程方便
- 二级页表其实是将原来的**要求连续**的页表，分成了多个**不要求连续**的页表，而且需要多查一次页表

## 二、虚拟内存

### 1. 虚拟寻址

- CPU将逻辑地址翻译成物理地址的过程。

- 避免直接操作物理内存造成的对操作系统的破坏
- 可以扩展内存

### 2. 什么是虚拟内存

- 操作系统提供的，比物理内存大很多的内存。
- 每一个程序都有一段**连续**的，独享的虚拟地址空间
- 将内存扩展到硬盘空间

### 3. 为什么要引入虚拟内存

两个原因：传统存储管理方式的局限性和局部性原理

- 传统存储管理方式：1.需要一次性将作业放入内存，作业过大无法装入内存时则无法执行，大量作业运行时，内存无法装下所有作业，造成效率降低。2.装入内存的作业直到作业执行完毕才会释放内存，即使因为IO阻塞等原因长期等待，也会占用内存。造成了内存资源极大浪费，效率还低下。
- **局部性原理**：1. 空间，当程序访问了某个存储单元，它大概率会在近期访问其周围存储单元（数据很多以数组之类的数据结构存储着）；2. 时间，某一条指令执行后，不久后该指令很可能再次执行（循环操作）。

- 这两个原因得出结论，程序执行时只需要将其一部分装入内存即可，在程序执行过程中如果需要使用没有装入内存的部分，可以将其调入，对于内存中长时间不使用的部分可以将其调出内存。从用户角度来开，操作系统好像提供了一个比物理内存大的多的内存，这就是**虚拟存储器**。
- 提高了内存的利用率，让程序获得了更多的可用内存

### 4. 实现虚拟内存

#### 4.1 请求分页

不是一次性调入内存，所以可能遇到请求的页不存在于内存的情况，处理这个情况的流程：

- 请求的页不在内存中时，产生**缺页中断**，保留CPU现场
- 程序请求操作系统将所缺的页调入内存，程序**阻塞**
- 若内存中有空闲块，则调入，更新页表，程序**唤醒**，查询页表，继续执行
- 无空闲块，通过**置换算法**淘汰某页，然后调入，淘汰的页**写回**外存

#### 4.2 页面置换算法

- 最佳置换算法OPT：替换最长时间内不再被访问的（无法预测，无法实现）
- 先进先出FIFO：可能内存空间越大，缺页率越高
- 最近最久未使用LRU：记录进入上次使用的时间，每次替换都要遍历，开销大
- CLOCK算法/最近未使用NRU：每块都有**访问位**`u`，进入内存时，`u`置为1，访问到时`u`置为1，需要替换时，遇到`u`为1的，置为0，检查下一个位置，直到遇到第一个`u`为0的替换出去。
- 改进型CLOCK算法：增加一个**修改位**`c`，第一轮遍历优先替换`c == 0, u == 0`的，不修改；第二轮替换`c == 1, u == 0`的，并且将遇到的u置为0。重复这两步。

##### 抖动

刚换出的页面又要访问，说明经常使用的页面数 > 内存容量，增大内存容量。





