# 概述

## 一、简述各层作用

- **应用层**：通过**应用进程**的交互为用户提供特定**网络服务**。比如说DNS提供域名解析服务，HTTP支持万维网应用，SMTP支持邮箱应用。
- **传输层**：两机通信与数据传输，TCP可靠通信，UDP不保证可靠性
- **网络层**：两机通信会经过很多子网和链路，网络层选择合适的路由和交换节点，确保数据及时传送
- **数据链路层**：两机之间数据传输，在链路上传输，提供链路协议
- **物理层**：两机之间比特流的传输提供支持，屏蔽传输介质和物理设备的差异

## 二、七层和四层协议

- **七层**：应用层下多了**表示层**和**会话层**
- 四层：**数据链路层**和**物理层**合为**网络接口层**

# 应用层

## 一、DNS

### 1. 简介

将域名和IP相互映射的一个**分布式数据库**

> - 使人不必去记住IP地址，只需要记住域名即可
>
> - 一般会用**UDP**传输，这就需要域名服务器和域名解析服务器自己处理**超时**和**重传**
>
> - 在**响应过大**（超过512字节，UDP支持的数据上限）或者**区域传送**（主域名服务器向辅助域名服务器传送变化的数据时）使用TCP

### 2. 访问过程

以`www.taobao.com`为例

- 浏览器输入域名，查找： **浏览器缓存** -> **本机host**，找不到就发送DNS查询请求
- 本机向**本地域名服务器**发送查询请求（看是否在**DNS缓存**中）
- **本地域名服务器**向**根域名服务器**查询，得到**顶级域名服务器**(.com域名服务器)的IP地址
- **本地域名服务器**向**顶级域名服务器**查询，得到**权限域名服务器**(.taobao域名服务器)的IP地址
- **本地域名服务器**向**权限域名服务器**查询，得到IP
- 写入缓存

> 查询过程简要说来就是：浏览器缓存 -> 路由器缓存 -> DNS缓存 
>
> 如果DNS缓存中不存在，就去其他域名服务器中查询
>
> 缓存过一段时间就会失效，因为域名和IP的关系总在变化

## 二、HTTP

### 1. 简介

- **超文本**传输协议（允许任何类型的数据对象）

> **超文本**：HTML CSS JavaScript 图片等。最初HTTP的出现是为了接受和发布HTML页面，现在也可以用于接受音频，视频，文件等内容

- 规定了**浏览器**和**服务器**之间请求和响应的**格式和规则**。

- **无状态**：每次HTTP请求都是**独立的**，任何两个请求之间没有任何必然联系
- **无连接**：每次服务端处理完客户端请求并且收到客户端应答后，就**断开通信**，客户端再次发送请求时必须建立新的连接（**HTTP/1.0的主要缺点**）

### 2. 不同版本HTTP协议的主要特点

#### 2.1 HTTP1.0

- 默认使用**短连接**（每次发送数据都需要经过三次握手和四次挥手）
- 不支持**Cookie**
- 不支持**断点续传**，每次都会传送全部的页面和数据

#### 2.2 HTTP1.1

> 改进

- 默认使用**长连接**（一次建立连接就可以多次传输数据，长连接维持时长可通过请求头中的`keep-alive`来设置）
- 引入**Cookie**技术
- 支持**断点续传**，使用请求头中`Range`实现

> 缺陷

- 没有**优先级**控制
- **串行请求**：客户端**顺序请求**，服务器**顺序响应**，如果服务器响应慢，会导致客户端一直请求不到数据，而且其他请求一直等待，出现**队头阻塞**问题
- 只能是客户端请求，服务端被动响应

#### 2.3 HTTP2.0

- **头部压缩**：HTTP1.1经常会出现`Cookie`，`Range`占用几百几千字节。如果发送多个头部相似或一样的请求，会**自动消除重复部分**
- **二进制格式**：不再使用纯文本报文，而是使用二进制格式（提升解析效率）
- **强化安全**：基于HTTPS
- **优先级**：客户端可以指定数据流的**优先级**
- **多路复用**：可同时发送多个请求，服务器不一定按照顺序一一回应。例如：如果A B请求，A很耗时，服务器先回应A处理好的部分，然后回应B请求，最后回应A剩下的部分

- **服务器推送**：浏览器请求HTML的时候，服务器可能会将要用到的JS、CSS等**静态资源**主动发给客户端，减少延时等待

### 3. Cookie和Session

- HTTP协议无状态，无法保存用户状态。例如，我登录了，但是我跳转到下一个链接，HTTP协议无状态，我仍需再次登录
- Session，服务器端保存用户状态。例如，用户登陆成功，服务器向redis中写入一个key和value，key中包含一个Session ID，这个Session ID会返回给客户端，value是用户信息。用户向购物车添加商品(跳转到一个新的页面)，服务器不知道哪个用户在添加商品，但是用户的浏览器带着Cookie，Cookie中带着这个Session ID，服务器一校验，就知道是哪个用户操作了。
- Session在服务器端，保存着数据，Cookie在客户端，仅仅保存Session ID
- 如果禁用Cookie，一般将Session ID附带在**URL**中

### 4. URI和URL

- URI类似身份证号，URL类似家庭住址。URI**唯一标识**一个资源
- URL用于定位这个资源，提供该资源的**路径**。

### 5. 消息结构

请求行 + 请求头 + 一个空行 + 消息主体

#### 5.1 格式

行：请求方式 请求资源 协议 / 协议 状态码 状态码的描述

头：

> **Date**：创建请求的时间
>
> **Connection**：是否持久连接keep alive，close
>
> **Content-Length**：请求体的长度
>
> **Set-Cookie**：设置cookie（SessionId）

体：数据

#### 5.2 请求方式

- **GET**: 获取资源
- **POST**: 传输数据，不安全，因为改变了服务器的状态（将数据保存）
- **HEAD:** 获取报文首部
- **PUT**: 传输文件
- **DELETE**: 删除文件

#### 5.3 状态码

- 1XX 信息类型，收到请求正在处理

> 100：到目前为止都正常，客户端可以继续发送

- 2XX 请求成功处理

> 200：服务器响应成功

- 3XX 重定向

> 301：永久重定向，说明请求的资源不存在，需要改用新的URL访问
>
> 302：临时重定向，说明请求的资源还在，但是暂时需要另一个URL访问

- 4XX 服务器无法处理请求

> 403：请求被拒绝
>
> 404：访问的资源不存在

- 5XX 服务器处理请求出错

> 500：服务器程序错误

### 6. GET和POST的区别

- **主要功能**：GET一般用于**请求**，POST一般用于**提交表单**（一个上传一个下载）
- **数据传输**：GET将参数放在URL后面，**不安全**，而且有**长度限制**。POST放在**请求体**中，对用户不可见，而且**长度无限制**。
- **请求过程**：GET只产生**一个**TCP数据包，将header和数据一并发送，服务器响应**200**。POST产生**两个**TCP数据包，先发送HTTP header，服务器响应**100**后再发送数据，服务器响应**200**。
- GET是**幂等**操作，POST不是

## 三、HTTPS（非对称加密，数字签名）

![2641864607-5e11d65c74244](E:\workspace\Play-with-Algorithms\img\2641864607-5e11d65c74244.png)

### 1. HTTP安全性问题

- 明文通信，易被**监听**（中间的路由器，运营商都可以劫持）
- 客户端服务器不相互**校验身份**，易被冒充（**中间人攻击**）
- 无法验证报文完整性，容易被**篡改**（请求头多一项少一项都不知道）

### 2. HTTPS的简介

- HTTPS不是新协议，而是由HTTP先与**SSL/TSL**通信，然后SSL/TSL与TCP通信
- 使用**非对称**方式传递对称加密要使用的**密钥**（随机key），然后用**对称加密**的方式传输数据，同时使用了非对称加密的**数字签名**功能（兼顾安全性和性能）

> - **对称加密**：加密和解密使用同样的密钥
>
> 速度快，但是无法安全的将**密钥**传输给通信方

> - **非对称加密**：加密和解密使用不同的密钥，分为公钥和私钥，公钥所有人都能获得，接收方使用私钥解密
>
> 速度慢，但是可以安全地将**密钥**传递给发送方
>
> HTTPS集合二者优点

### 3. 为什么需要数字签名

#### 3.1 如果完全使用非对称加密（可行，消耗大）

- 客户端有公钥 A1 私钥 A2；服务端有公钥 B1 私钥B2
- 二者相互传递公钥，然后使用公钥加密，私钥解密的方式来传递信息

> **安全性**保证了
>
> 非对称加密解密**耗时**远大于对称加密，**性能损耗**较大

#### 3.2 如果不完全使用非对称加密（中间人攻击）

<img src="E:\workspace\Play-with-Algorithms\img\640.webp" alt="640"  />

- 如图所示，如果没有数字签名校验证书是否被修改，中间人完全可以通过在数字证书中**替换公钥**来得到最后通信时使用的**密钥**（随机Key）
- 数字签名其实就是防伪技术，避免有人篡改数字证书

### 4. 工作流程

- 用户发起请求(www.baidu.com)，默认使用443端口连接
- 服务器向第三方机构申请**数字证书**，获得一个**公钥**和与之对应的**私钥**

> **数字证书**中包含：**公钥**，颁发机构信息，证书有效期等明文信息和一个**数字签名**
>
> **私钥**保存在服务端不公开

- 服务端响应请求，并且携带**明文信息**和**数字签名**（数字证书）
- 客户端收到证书，通过**数字签名校验明文信息的合法性**（检查是否被篡改），不合法则显示警告信息，合法则继续
- 客户端生成**随机key**（密钥），用证书内的**公钥**加密发送给服务端
- 服务端使用**私钥**解密，得到**随机key**，随后二者使用**随机key**对称加密解密

#### 4.1 数字签名的原理

- CA认证机构，使用**私钥**对数字证书的**明文**部分进行**加签**（先哈希再加密）

> 哈希主要是得到固定长度的信息，避免耗时过长

- 客户端得到**数字证书**(数字签名 + 明文数据)后，用**公钥**对**数字签名**进行**解签**

> 因为CA是第三方信任机构，所以浏览器会内置其证书，也就会得到其公钥

- 如果解签后的结果与**明文部分**相等，则证明没有篡改

![v2-c351011aed3f71512b06c78423427e0a_720w](E:\workspace\Play-with-Algorithms\img\v2-c351011aed3f71512b06c78423427e0a_720w.jpg)

### 5. HTTP和HTTPS的区别

- HTTPS在HTTP和TCP之间加了一层SSL/TSL协议
- HTTP未加密，HTTPS进行了加密（因为加密所以速度慢）

- HTTP默认端口80，HTTPS默认端口443
- HTTPS认证费用高昂

## 四、浏览一个网页发生了什么

- **生成HTTP数据报**：根据URL生成HTTP请求消息
- **域名解析**：DNS将域名解析为IP，得到目标服务器的ip
- **建立连接**：通过IP，使用TCP三次握手建立连接

>TCP三次握手需要传输数据：
>
>- 网络中：**OSPF协议**进行**路由选择**，使用**ICMP协议**进行**消息通知**
>- 路由器之间：**ARP协议**来获得**MAC地址**，将**IP数据报**封装为**MAC帧**进行传输

- **发送请求**：浏览器带着Cookie向Web服务器发送HTTP请求

- **接收响应**：浏览器接收响应，解析渲染页面

> **路由器**每个端口有的IP和MAC地址，就像**网卡**一样，收到**MAC帧**会拆开得到**IP数据报**，然后**重新包装**发送
>
> **交换机**没有独立IP和MAC地址，不同路由器通过交换机连接

# 传输层

为两机之间的进程通信提供传输服务。

**复用**：不同的应用层应用可以使用同一个传输层来服务

**分用**：传输层可以将接收到的信息交给不同的应用——接口

## 一、TCP

### 1. 什么是TCP协议

**面向连接**，**可靠的**（无损，有序，非冗余），**基于字节流**的传输层通信协议

- **面向连接**：一对一，必须建立连接

> 所谓的连接由**Socket**、**序列号**和**窗口大小**构成
>
> - **Socket**：IP + 端口号（双端共四个参数来确定一个连接）
>
> > 所以最大TCP连接数就是 端口数 * IP数
>
> - **序列号**：用来解决乱序问题
> - **窗口大小**：流量控制

- **可靠**：保证报文一定到达接收端
- **字节流**：会将应用层的数据进行拆分封装

### 2. 三次握手

#### 1.1 流程

- **客户端A**向**服务端B**发送请求，请求建立连接，报文中标志位`SYN = 1`

> - 客户端发送的报文中，**随机初始化**序列号为`a`，SYN置1，然后发送，不携带数据
> - ACK为1时，**确认应答号**（期待收到的报文的序号）变为有效，除了这个请求连接的报文外，其他的报文ACK必须置为1

- 服务端B收到请求，**分配资源和缓存**，发送确认应答报文，标志位SYN = 1， ACK = 1、

> - 服务端也随机初始化序列号为`b`，确认应答号为`a + 1`，不携带数据
>
> - 可能受到洪泛攻击（因为这一步分配了资源）

- 客户端A接收报文，**分配资源和缓存**，发送确认报文，标志位ACK = 1

> - 序列号为`a + 1` 确认应答号为`b + 1`，这一步可以携带数据

#### 1.2 为什么要回传SYN

- SYN是为了建立从服务端到客户端的通信（同步序列号）

> 告诉客户端，服务端收到的信息确实是你发送的请求建立连接的信号

#### 1.3 为什么不是两次握手

- 避免**历史报文建立连接**

> - 由于复杂的网络环境，**旧的**请求建立连接的报文比**新的**报文先到，则服务器根据旧的报文返回确认报文
> - 如果三次握手，客户端可以根据上下文（标志位，序列号，确认应答号）判断是历史连接，然后三次握手时使用`RST = 1`中止连接
> - 两次握手则无法判断

- 同步**双方初始化序列号**

> - 客户端发送**请求连接报文**后，需要获得服务端的`SYN=1`的**确认响应报文**
> - 服务端发送**确认响应报文**后，同样需要客户端的**确认报文**才能保证序列号同步

- 避免**资源浪费**（其实和第一点一样）

> - 连接关闭后，旧的请求连接（网络原因）的报文到达，服务端分配资源，发送确认响应报文，但是客户端连接已经关闭，服务端资源迟迟得不到释放
> - 或者会造成服务端重复分配资源，建立冗余连接

#### 1.4 为什么随机序列号

- 网络环境复杂，延迟，重发，丢失，为了避免不同连接相互影响，所以使用随机

#### 1.5 SYN攻击 （洪泛法）

- **SYN接收队列**：收到请求连接的报文，加入SYN队列，还未分配资源和返回SYN报文
- **Accept队列**：收到客户端的ACK报文，将SYN队列中的信息放到Accept队列，还未应用连接

**应对策略一**：

- 控制服务端接收队列的大小，并且设置队列满的处理策略（返回RST报文，丢弃连接）

### 3. 四次挥手

#### 2.1 流程

- A和B任何一方都可以主动发起断开连接请求
- A数据发送完毕，向B发送断开连接请求，标志位FIN = 1
- B收到，发送确认收到，A -> B的连接断开，标志位ACK = 1
- B数据发送完毕后，发送断开连接请求，标志位FIN = 1
- A收到后，发送确认收到，标志位ACK = 1，2MSL(2倍的最长报文寿命)后B -> A连接断开

#### 2.2 为什么要等待2MSL

- B请求关闭连接
- 若B未收到A发送的确认关闭报文，则会尝试重新发送。
- 如果不等，直接关闭，A收到B重发的关闭报文不予理睬，B资源缓存得不到释放

### 4. 如何保证可靠传输

- 将数据切分为大小合适的块，并且为每一块编号

#### 2.1 重传机制

- **序列号**与**确认应答号**：每个发送出去的报文都必须返回一个确认报文（如果丢失则启用重传机制）

- **超时重传**：每发送一个报文就维持一个计时器，如果规定时间没有收到确认报文，则重传

> 如果超时重传的数据再超时，则会将超时时间间隔加倍

- **快速重传**：收到的3个**冗余ACK**则重传目标报文

> **冗余ACK**，应该收到2号报文，但是却受到3号，则发送一个冗余ACK给发送方

#### 2.2 滑动窗口

- **窗口**：无需确认应答可以发送的数据的最大值（发一个就等一个确认报文太慢了）
- **累计确认**：收到了3号的确认报文，说明接收方1,2也都接收到了

#### 2.3 流量控制（针对一条连接）

- 基于滑动窗口实现，接收方返回确认报文，首部可以携带自己还能接受的数据量的信息（**接收窗口**）
- 发送方根据这个信息动态调整**发送窗口**大小

#### 2.4 拥塞控制（针对整个网络状态）

- **拥塞窗口**是发送窗口的大小
- **慢开始**：每收到一个确认报文，则拥塞窗口 + 1， 指数增长
- **拥塞避免**：增长到一个阈值后，开始线性增长，每经过一个往返时延，拥塞窗口 +1
- 出现**超时**：阈值变为当前拥塞窗口的一半，拥塞窗口置位1
- 出现**冗余ACK**：**快重传**：3个冗余ACK则重传目标报文。**快恢复**：重传后，阈值变为当前拥塞窗口一半，拥塞窗口也减半（而不是变成1）。

## 二、TCP和UDP异同

- TCP面向**连接**，先建立连接再传输数据，保证**可靠**交付，UDP无连接，不保证可靠交付
- TCP只支持一对一全双工通信，UDP支持一对多，多对多

> TCP适用于文件传输，邮件，UDP适用于要求延时小的地方，直播，语音通话

- TCP面向**字节流**，对于应用层传递来的数据，进行拆分封装，UDP面向报文，对于应用层传递来的数据，只封装不拆分
- TCP有**拥塞控制**，UDP没有，即使网络拥塞也不降低发送速率，**实时性**好，有丢包风险
- TCP**首部**开销大 20字节，UDP首部开销小 8字节



# 网络层

## 一、ARP 地址解析协议

**作用**：找到接收方的MAC地址

**过程**：

- 在主机上查缓存，查IP和MAC地址的对应关系
- 没有就广播ARP分组请求，会有路由器或者主机响应
- 响应中携带对应关系或者是下一个路由器的IP地址

**ARP攻击**：

- 响应的IP和MAC可能是伪造的

## 二、ICMP协议

- 告知网络传输过程中产生的错误以及控制信息

## 二、RIP路由协议（UDP）

- 每隔**固定时间**，就和**周围的路由器**交换本机的**全部信息**

- 维护到达目标路由器**经过路由器最少**的路径
- 实现简单，收敛快，适用网络规模小，某一处出故障时坏消息传的慢

> 随着网络规模扩大，交换信息开销增大
>
> 因为每次都和周围交换信息，所以某处故障的信息需要很久才会传递到所有路由器

## 三、OSPF路由协议（IP数据报）

- 向区域中**所有路由器**发送（洪泛法）本**路由器周围**的链路信息

> 通过迪杰克斯拉算法计算最优路径
>
> 为了避免网络规模过大时造成的影响，还将网络划分为多个区域

- **链路发生变化**时，用洪泛法向**所有路由器**发送**此信息**
- 每隔一段时间刷新一次链路状态



# 待整理

## 五、RTP协议

即real-time transport protocol（实时传输协议），为实时传输交互的音频和视频提供了端到端传输服务 多播  比如说一个会议

- 将实时流媒体封装，首部标明了该媒体的**编码方式**和**时间戳**（恢复时序的关键）
- **RTP用来为端到端的实时传输提供时间信息和流同步，但并不保证服务质量。服务质量由RTCP来提供。**
- 然后交由UDP传输
- 音频视频独立分发，需要建立两个名字相同的Session  所以会音画不同步
- Mixer，有些与会者网络较差，会用这个RTP级别的中间节点进行数据压缩
- Translator，有些用户在防火墙后，无法通过IP组播访问，防火墙两端各一个Translator，来将报文发送



RTCP

- 基于UDP传输，只有控制信息，可以多个RTCP封装在一个UDP中
- 二者用**一对**端口传输
- 用于向接收端报告发送情况（多播），以及向发送端报告接受情况，还有用来断开连接（接受者离线）。