

# 一、MySQL概述

MySQL是开源，免费的关系型数据库，默认端口号3306

## 1. 底层结构

### 1. 如何从数据库中查找数据（为什么使用 B树）

- 数据库会有索引，索引存在磁盘中，我们通过索引查找数据的位置
- 数据量很多时，索引可能会有几个G，所以我们不可能将索引全部读入内存后从中找到我们需要的数据，我们只能按照一定规则逐一加载磁盘页，然后找到数据

- 索引有很多存储形式，我们假设它以**二叉搜索树**存储（其实并不是

<img src="E:\workspace\Play-with-Algorithms\img\6954572-0951c4a92f287c47.webp" alt="6954572-0951c4a92f287c47" style="zoom:50%;" />

> 假设我们从下面的二叉树索引中查找索引10

<img src="E:\workspace\Play-with-Algorithms\img\6954572-8144d32410741c98.webp" alt="6954572-8144d32410741c98" style="zoom:80%;" />

- 将9读取到内存，索引10 > 9，所以向右找到13
- 将13读取到内存，重复上面步骤，直至找到10
- 总共进行了4次IO —— **IO次数是树的最大深度**
- 因此，我们需要一种数据结构，来减少IO次数，减少最大高度

### 2. B树

对于一个m阶B树，m >= 2（m是每个节点最多分几个叉，二叉树就是m==2）：

> B树可以理解为n叉树，一个节点可以有好多个元素，元素排列方式还是类似平衡二叉树，左小右大
>
> 2-3树其实就是一个3阶B树，有复杂的自平衡措施
>
> m受限于磁盘页的大小，页是内存调度的基本单位

- 根节点至少有2子节点
- 每个中间节点都有 k - 1个元素和k个孩子， m/2 <= k <= m（类似满二叉树，非叶子节点必须每个叉都有孩子
- 每个叶子节点都有 k - 1个元素， m/2 <= k <= m
- **所有叶子节点位于同一层**
- 每层元素**从小到大排列**（还要遵守左小右大）

### 3. B+树

B树的优化版

- 非叶子节点不存储数据，只保存索引（使得一个磁盘块能保存的索引数大大增加，m上限提高，树高下降
- 叶子节点保存了父节点所有元素的索引
- 相邻叶子结点从左到右有指针相连

优点：

- 因为数据都在叶子结点，叶子结点在同一层，所以每次查找所花费时间相同
- 树高更低，磁盘IO次数减少
- 全数据遍历只需要遍历叶子结点（叶子结点相连），不需要遍历整个树

缺点：

- 如果经常访问的数据在B树中，离根节点近，则访问速度可能超过B+树

### 查找数据流程

- 在根节点二分查找，找到一个子节点的索引
- 重复二分查找找到叶子节点
- 在叶子节点上二分查找到data

## 2. 索引

索引是存储引擎实现的。MySQL主要使用BTree索引和哈希索引

### 2.1 为什么使用索引

- 通过创建唯一索引，保证每一行数据的唯一性
- 减少数据搜索量，加快检索速度（索引一半远小于数据）
- 随机IO变为顺序IO
- 帮助服务器避免排序和分组
- 但是创建和维护索引需要消耗时间和资源，所以不能无脑创建索引

### 2.2 分类

#### 1. B+Tree索引

- MySQL引擎默认的索引类型，有序
- 可以指定多个列作为索引

> 对于MyISAM，叶子节点data域存放数据记录的地址，索引文件和数据文件分离，非聚簇索引
>
> 对于InnoDB，叶子结点data域保存了完整的数据，key则是主键，称为聚簇索引，一个表中只有一个主键，因为不能将数据存放在两个地方
>
> 其他的索引都是辅助索引，辅助索引的叶子结点存放着主键key，拿到主键后再去主索引中找data

```sql
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `name` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '名称',
  `age` int(3) unsigned NOT NULL DEFAULT '1' COMMENT '年龄',
  PRIMARY KEY (`id`), # 主键
  KEY `I_name` (`name`) # 键
) ENGINE=InnoDB;
```

这样，会有两个索引表，两棵B+树

- 主索引叶子结点存放数据
- 辅助索引叶子结点只有主键值

<img src="E:\workspace\Play-with-Algorithms\img\20200623171319.png" alt="20200623171319" style="zoom:80%;" />

- 为什么推荐主键自增长

> 因为聚簇索引中叶子结点存放数据，且有序，如果主键自增长，则每次增加只需要顺序的添加到现有数据后即可，一个页满，添加新的一个页面，自动填充页面。如果主键随机生成，则会存在大量数据移动的问题，类似于数组中插入一个数，效率较低

#### 2. 哈希索引

- 以O(1)速度查询，但是失去了有序性，不能排序，分组
- 无法范围查找，只能精确查找
- 底层是哈希表

> InnoDB会在某一个索引被频繁使用时，会在B+Tree索引上创建一个哈希索引

#### 3. 全文索引

查找文本中的关键词，而不是直接比较是否相等

#### 4. 空间数据索引

地理数据的存储

### 2.3 索引优化

#### 1. 索引必须是独立的列

索引不能是表达式的一部分，例如下例

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

#### 2. 多列索引

条件有多个列时，使用多列索引性能更好

```sql
SELECT film_id, actor_ id FROM sakila.film_actor # 多列索引
WHERE actor_id = 1 AND film_id = 1;   # 条件
```

#### 3. 索引的顺序

选择性最强的索引放前边

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity, # 这个放前边更好
COUNT(*)
FROM payment;
```

#### 4. 覆盖索引

> 索引中就包含所有需要查询的字段，性能更好，一个例子：

- 还是上边的例子，我们使用name和age建立联合索引

```sql
ALTER TABLE student DROP INDEX I_name;
ALTER TABLE student ADD INDEX I_name_age(name, age); # 建立联合索引
```

- 索引表变为这样

<img src="E:\workspace\Play-with-Algorithms\img\20200623171845.png" alt="20200623171845" style="zoom:80%;" />

- 查询

```sql
SELECT age FROM student WHERE name = '小李'；
```

- 不会再去查询主索引，直接在联合索引中，找到了年龄12

> 优点：

- 索引通常远小于数据行，减少数据访问量
- InnoDB中，不需要访问主索引

# 二、事务

## 1. 什么是事务

逻辑上的一组操作，要么都执行，要么都不执行

## 2. 四大特性（ACID）

- 原子性：不允许分割，要么都完成，要么都不执行
- 一致性： 事务前后数据保持一致，多个事务对同一个数据读取结果一样
- 隔离性： 事务独立，不受其他事务影响（一个事务所做的修改在最终提交以前，对其它事务是不可见的。）
- 持久性： 事务对数据库的改变是持久的，即使崩溃事务执行的结果也不能丢失

![20200624104836](E:\workspace\Play-with-Algorithms\img\20200624104836.png)

## 3. 并发事务带来的问题

- 脏读：事务A修改数据到一半，还没提交，事务B就读取数据，这个数据就是**脏数据**
- 丢失修改：事务A B先后对数据修改，A修改还没提交，B又修改了，A的修改就丢失了（隔离性）
- 不可重复读：事务A连续读取数据两次，两次中间事务B**修改数据**，则两次读取的不一致（一致性）
- 幻读：事务A读取数据到一半，B又**添加或删除**了很多数据，A就发现数据凭空产生或消失

## 4. 事务隔离级别（解决并发事务带来的问题）

- **读取未提交**：可以读取未提交的数据——脏读，不可重复读，幻读
- **读取已提交**：可以读取已提交的数据——不可重复读，幻读
- **可重复读**：对同一字段多次读取都一致——幻读
- **可串行化**：最高隔离级别，消除并发，串行执行

## 5. 如何实现事务隔离

### 5.1 锁机制（机制） 

MySQL提供两种粒度（级别）的锁：**行级锁**以及**表级锁**，默认使用行级锁

- 锁定的数据量越小，并发程度越高
- 锁定的数据量越小，系统开销越大（会使用更多的锁）

#### 锁类型

##### 读写锁

加了X锁，就独享读写权限；加了S锁就可以读，其他人此时也可以加S锁来读，但不能加X锁来NTR。**行和表**都可以用X和S锁

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

##### 意向锁

因为有行级锁和表级锁存在，所以如果事务想对表加X锁，就需要扫描表上有没有锁，再扫描**每一项**有没有锁，过于耗时。引入IS IX锁，都是**表级锁**，目的就是标识这个**表**是否可以上X或S锁。

> 为什么叫意向锁，因为这只是一种意向，**并不是真正加锁**，例如A和B分别想对第1，2行加X锁，则都先对表加IX（IX/IS都相互兼容），都成功，然后对1,2行加X锁。如果C相对表加X锁，就要等到表上没有IX锁和IS锁才可以进行加锁。

- 对行加S锁前，必须对表加IS锁
- 对行加X锁前，必须对表加IX锁
- InnoDB自加，不须用户干预
- 其实并没有锁定任何资源，只是为了减少查询的次数

### 5.2 多版本并发控制 MVCC（具体实现）

MySQL的InnoDB引擎实现隔离级别的具体方式，实现了**读取已提交**和**可重复读**两种隔离级别。**可串行化**需要对所有读取的行加锁，MVCC无法实现

#### 基本思想

- 实际使用数据库时，读操作多于写操作，读写锁，二者互斥
- MVCC利用多版本思想，读操作就在旧版快照（原来数据）上读，写操作（DELETE INSERT UPDATE）修改最新版快照，二者不再互斥
- 脏读和不可重复读本质都是A读到了B未提交的数据，为了解决，MVCC规定**只能读取已经提交的快照**

#### 具体实现

- SELECT 不再需要加锁，因为读取的是旧版快照的数据
- DELETE INSERT UPDATE 仍需要加锁，为了保证修改的是最新版的快照
- MVCC只是避免了SELECT的加锁操作

### 5.3 Next-Key Locks（具体实现）

- Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

- 在可重复读的条件下，通过MVCC + Next-Key Locks解决幻影读
- 需要除了主索引外还有

#### Record Locks

- 锁定一个记录上的索引，而不是记录本身
- 如果没有设置索引，则会自动在主键上创建聚簇索引

#### Gap Locks

- 锁定索引之间的间隙

#### Next-Key Locks

- Record Locks 和 Gap Locks 的结合，锁定一个记录上的索引，还锁定这个索引左右两侧的间隙
- 前开后闭
- 对于单一索引，退化为Record Locks，只有多索引查询才用这个



# 三、查询性能优化

MySQL数据项过多时性能下降，常见的优化措施：

## 1. 分析方法

使用explain分析， 几个关键的参数

- select_type: 查询的类型，简单查询，联合查询，子查询等
- key: 使用的索引
- rows: 扫描的行数

## 2. 从查询语句入手

### 2.1 限定数据范围，减少请求的数据量

- 查询近一个月的订单（限制行数）
- 尽量不用SELECT * ，只返回必要的列（限制列数）
- 使用缓存

### 2.2 减少服务端扫描的行数

覆盖查询（参考2.3索引优化）

## 3. 从数据库结构入手

### 3.1 读写分离

主库负责写，从库负责读。使用代理服务器，请求来时，它决定转发到哪个服务器（主库/从库）

### 3.2 垂直分区

列太多的时候，拆成多个表或者多个数据库

- 优点：数据项数据减少，每个磁盘块放的数据变多，减少IO次数
- 缺点：主键冗余，查询变复杂

### 3.3 水平分区

拆分到多个相同结构的表中，需要有一个全局id

# 四、存储引擎

5.5版本之前，MyISAM是MySQL的默认数据库引擎，5.5版本之后引入InnoDB，事务性数据库索引，作为默认引擎。

### MyISAM和InnoDB区别

- 是否支持行级锁： InnoDB支持，MyISAM不支持
- 是否支持事务：InnoDB支持，MyISAM不支持
- 是否支持外键：InnoDB支持，MyISAM不支持
- 是否支持MVCC： InnoDB支持
- MyISAM 非聚簇索引，InnoDB 聚簇索引
- InnoDB不支持全文索引，MyISAM支持

# 五、琐碎知识

### 1. delete和truncate 的区别

- delete更灵活，可以删除一行数据
- delete删除表示一行一行删除，truncate是删除表后重建
- delete可以回滚，truncate不可以
- delete后，主键延续，truncate主键重置

### 2. 悲观锁与乐观锁

- 悲观锁，总是假设最坏的情况，每次有人来拿数据，都假设他会修改数据，都必须上锁。比如说，读写锁，表级锁等
- 乐观锁，总是假设最好的情况，认为别人拿走数据不会修改，所以不加锁。