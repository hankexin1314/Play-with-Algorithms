#### [633. 平方数之和(双指针入门)](https://leetcode-cn.com/problems/sum-of-square-numbers/)

思路比较简单，找到左右边界，使用双指针解决。

时间复杂度: sqrt(c)

```java
public boolean judgeSquareSum(int c) {

    if(c < 0) return false;
    int a = 0, b = (int)Math.sqrt(c) + 1;
    while(a <= b) {
        int num = a * a + b * b;
        if( num == c) return true;
        else if(num < c) a++;
        else b--;
    }

    return false;
}
```

#### [345. 反转字符串中的元音字母(分类讨论，使用递归和for简化代码)](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

思路依旧类似，但是加入了可删除一个字母的设定，就需要分类讨论，是删除左侧还是右侧。

使用递归会更加简洁，while循环也可以使用for替代。

```java
public boolean validPalindrome(String s) {

    if(s == null || s.length() == 0) return false;
    int l = 0, r = s.length() - 1;
    char[] chars = s.toCharArray();
    while(l < r) {
        if(chars[l] == chars[r]) {
            l ++;
            r --;
        }
        else {
            boolean flag1 = true, flag2 = true;
            int l1 = l + 1, r1 = r; // 删除左边
            while(l1 < r1) {
                if(chars[l1] == chars[r1]) {
                    l1 ++;
                    r1 --;
                }
                else {
                    flag1 = false;
                    break;
                }
            }
            int l2 = l, r2 = r - 1; // 删除右边
            while(l2 < r2) {
                if(chars[l2] == chars[r2]) {
                    l2 ++;
                    r2 --;
                }
                else {
                    flag2 = false;
                    break;
                }
            }
            return flag1 || flag2;
        }
    }
    return true;
}
```

递归版本

```java
public boolean validPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
    }
    return true;
}

private boolean isPalindrome(String s, int i, int j) {
    while (i < j) {
        if (s.charAt(i++) != s.charAt(j--)) {
            return false;
        }
    }
    return true;
}
```

#### [88. 合并两个有序数组(从前往后和从后往前)](https://leetcode-cn.com/problems/merge-sorted-array/)

- 从后往前避免使用额外空间，而且在一定程度上可以提高速度。

- 使用for循环而不是传统的while。

  ```java
  public void merge(int[] nums1, int m, int[] nums2, int n) {
  
      int p1 = m - 1, p2 = n - 1;
      for(int i = m + n - 1; i >= 0; i--) {
          if(p1 < 0) {
              nums1[i] = nums2[p2];
              p2 --;
          }
          else if(p2 < 0) break; // 相比于从前往后，这里有一定的提升
          else if(nums1[p1] >= nums2[p2]) {
              nums1[i] = nums1[p1];
              p1 --;
          }
          else {
              nums1[i] = nums2[p2];
              p2 --;
          }
      }
  }
  ```

  