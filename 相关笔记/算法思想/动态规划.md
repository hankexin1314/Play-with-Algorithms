### 斐波那契数列

#### [70. 爬楼梯(经典入门)](https://leetcode-cn.com/problems/climbing-stairs/)

- 状态转移方程
  $$
  dp_n = dp_{n-1} + dp_{n-2}
  $$

- 优化方案是将dp数组优化为 两个数字

```java
public int climbStairs(int n) {

    if(n < 2) return 1;
    int a = 1, b = 1;
    for(int i = 2; i <= n; i++) {
        int tmp = a;
        a = b;
        b = tmp + b;
    }

    return b;
}
```

#### [198. 打家劫舍(加入额外限制)](https://leetcode-cn.com/problems/house-robber/)

- 关注前两个元素的值，dp[i]表示抢劫[0: i]能获得的最大值
- 两种情况，本质是抢第i家和不抢第i家进行比较

$$
dp_n = max(dp_{n - 1}, dp_{n - 2} + a_n)
$$

#### [213. 打家劫舍 II(加入环形限制)](https://leetcode-cn.com/problems/house-robber-ii/)

- 要求[0: n]能抢到的最大值，依旧是关注[0: n-1] [0: n-2]能抢到的最大值
- 加入了环形限制，使得第一个和最后一个节点比较特殊，我们单独处理
- 分为两部分计算 [0 : n - 1] [1: n]对应是否有 第一个节点，计算两次，求最大值
- 本质还是是否抢劫第i家

#### [*337. 打家劫舍 III(二叉树)](https://leetcode-cn.com/problems/house-robber-iii/)

- 本质是 是否抢劫当前节点，使用辅助函数，仅仅返回一个值无法代表是否抢劫当前节点，返回一个二维数组才可以表示

```java
public int rob(TreeNode root) {

    int[] res = helper(root);
    return Math.max(res[0], res[1]);
}

private int[] helper(TreeNode root) {

    int[] res = new int[2];
    if(root == null) return res;
    int[] left = helper(root.left);
    int[] right = helper(root.right);

    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    res[1] = left[0] + right[0] + root.val;

    return res;
}
```



#### *信件错排

##### 题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

[![img](https://camo.githubusercontent.com/4428ca70270bea28468fcc209d54de9000103b3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64613166393662392d666434642d343463612d383932352d6662313463353733333338382e706e67)](https://camo.githubusercontent.com/4428ca70270bea28468fcc209d54de9000103b3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64613166393662392d666434642d343463612d383932352d6662313463353733333338382e706e67)

### 矩阵路径

#### [64. 最小路径和(经典入门)](https://leetcode-cn.com/problems/minimum-path-sum/)

- 辅助空间使用一个**二维数组**或者优化为一个**一维数组**或者直接在**原数组上填充**
- 还可以根据情况选择从前往后填充还是从后往前填充

```java
public int minPathSum(int[][] grid) {

    if(grid == null || grid.length == 0 || grid[0].length == 0) 
        return 0;
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    dp[0] = grid[0][0];
    for(int i = 1; i < n; i++) dp[i] = dp[i - 1] + grid[0][i];

    for(int i = 1; i < m; i++) {
        dp[0] += grid[i][0];
        for(int j = 1; j < n; j++)
            dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j]);
    }

    return dp[n - 1];
}
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

与上题基本相同

### 数组区间

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

维护一个sum数组，sum[i]表示nums[0: i]的和

#### [*413. 等差数列划分(dp[i]不是最终结果)](https://leetcode-cn.com/problems/arithmetic-slices/)

[1, 2, 3]   dp[3] = 1

[1, 2, 3, 4] dp[4] = dp[3] + 1 // 1代表 1234本身， dp[3]代表 2 3 4和dp[3]一样

最后求和需要将其加起来

```java
public int numberOfArithmeticSlices(int[] A) {

    if(A == null || A.length == 0) return 0;
    int[] dp = new int[A.length];
    for(int i = 2; i < A.length; i++) {
        if(A[i - 1] - A[i] == A[i - 2] - A[i - 1])
            dp[i] = dp[i - 1] + 1;
    }

    int res = 0;
    for(int num: dp)
        res += num;

    return res;
}
```

### 分割整数

#### [343. 整数拆分(需要和之前所有结果进行比较)](https://leetcode-cn.com/problems/integer-break/)

分割尽量多的 3 和 2， 3优先

动态规划，dp[i]表示 i能获得的最大乘积

```java
public int integerBreak(int n) {

    if(n < 2) return 0;
    int[] dp = new int[n + 1];
    for(int i = 2; i < n + 1; i++) {
        int max = -1;
        for(int j = 1; j <= i / 2; j ++) { // 拆分一个j出来
            max = Math.max(max, j * Math.max(i - j, dp[i - j]));
        }
        dp[i] = max;
    }

    return dp[n];
}
```

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

和上题类似

### 最长递增子序列

#### [*300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

动态规划，和数组区间的题类似，时间复杂度
$$
O(n^2)
$$

```java
public int lengthOfLIS(int[] nums) {

    if(nums == null || nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    for(int i = 0; i < nums.length; i++) {
        int max = dp[i];
        for(int j = i - 1; j >= 0; j--) {
            if(nums[j] < nums[i])
                max = Math.max(max, dp[j] + 1);
        }
        dp[i] = max;
    }

    int res = -1;
    for(int num: dp) res = Math.max(res, num);
    return res;
}
```

### 最长公共子序列

#### [1143. 最长公共子序列(二维dp数组)](https://leetcode-cn.com/problems/longest-common-subsequence/)

### 0-1 背包

#### [*416. 分割等和子集(经典入门)](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

- 找到target后遍历所有可能，超时
- 求什么就定义什么。求是否可以用这些元素组合得到target，定义状态 dp[n, i] 是否可以用前n个元素填满容量为i的背包

```java
public boolean canPartition(int[] nums) {

    int sum = 0;
    for(int num: nums) sum += num;
    if(sum % 2 != 0) return false;
    int target = sum / 2;
    boolean[] dp = new boolean[target + 1];
    Arrays.fill(dp, false);
    if(nums[0] <= target) dp[nums[0]] = true;
    dp[0] = true;
    for(int i = 1; i < nums.length; i++) {
        for(int j = target; j >= 0; j--) {
            dp[j] = dp[j] || (j - nums[i] >= 0 && dp[j - nums[i]]);
            if(dp[target]) return true;
        }
    }

    return false;
}
```

#### [*494. 目标和(经典)](https://leetcode-cn.com/problems/target-sum/)

- 可以优化为一个2行的二维数组
- 思路并不难，但是由于复数以及0的存在，使得需要考虑的条件很多
- dp[i, j]表示 前 i个数  组成j 有几种可能

```java
public int findTargetSumWays(int[] nums, int S) {

    int sum = 0;
    for(int num: nums) sum += num;
    S = Math.abs(S); // S可能为负 但是对称，所以转化为正
    if(S > sum) return 0;
    int[][] dp = new int[nums.length][sum + 1];
    if(nums[0] == 0) dp[0][nums[0]] = 2; // +0 -0 都是0
    else dp[0][nums[0]] = 1;
    for(int i = 1; i < nums.length; i++) { // 第几个数字
        int num = nums[i];
        for(int j = 0; j < sum + 1; j++) { // 目标和为几
            int l = dp[i - 1][Math.abs(j - num)]; // num 前面加正号
            int r = (j + num) <= sum ? dp[i-1][j + num]: 0; // num加负号
            dp[i][j] = l + r;
        }
    }

    return dp[nums.length - 1][S]; // 前面保证过S在小于等于sum 且为正
}
```

