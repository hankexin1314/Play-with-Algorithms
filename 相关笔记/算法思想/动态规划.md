### 斐波那契数列

#### [70. 爬楼梯(经典入门)](https://leetcode-cn.com/problems/climbing-stairs/)

- 状态转移方程
  $$
  dp_n = dp_{n-1} + dp_{n-2}
  $$

- 优化方案是将dp数组优化为 两个数字

```java
public int climbStairs(int n) {

    if(n < 2) return 1;
    int a = 1, b = 1;
    for(int i = 2; i <= n; i++) {
        int tmp = a;
        a = b;
        b = tmp + b;
    }

    return b;
}
```

#### [198. 打家劫舍(加入额外限制)](https://leetcode-cn.com/problems/house-robber/)

- 关注前两个元素的值，dp[i]表示抢劫[0: i]能获得的最大值
- 两种情况，本质是抢第i家和不抢第i家进行比较

$$
dp_n = max(dp_{n - 1}, dp_{n - 2} + a_n)
$$

#### [213. 打家劫舍 II(加入环形限制)](https://leetcode-cn.com/problems/house-robber-ii/)

- 要求[0: n]能抢到的最大值，依旧是关注[0: n-1] [0: n-2]能抢到的最大值
- 加入了环形限制，使得第一个和最后一个节点比较特殊，我们单独处理
- 分为两部分计算 [0 : n - 1] [1: n]对应是否有 第一个节点，计算两次，求最大值
- 本质还是是否抢劫第i家

#### [*337. 打家劫舍 III(二叉树)](https://leetcode-cn.com/problems/house-robber-iii/)

- 本质是 是否抢劫当前节点，使用辅助函数，仅仅返回一个值无法代表是否抢劫当前节点，返回一个二维数组才可以表示

```java
public int rob(TreeNode root) {

    int[] res = helper(root);
    return Math.max(res[0], res[1]);
}

private int[] helper(TreeNode root) {

    int[] res = new int[2];
    if(root == null) return res;
    int[] left = helper(root.left);
    int[] right = helper(root.right);

    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    res[1] = left[0] + right[0] + root.val;

    return res;
}
```



#### *信件错排

##### 题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

[![img](https://camo.githubusercontent.com/4428ca70270bea28468fcc209d54de9000103b3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64613166393662392d666434642d343463612d383932352d6662313463353733333338382e706e67)](https://camo.githubusercontent.com/4428ca70270bea28468fcc209d54de9000103b3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64613166393662392d666434642d343463612d383932352d6662313463353733333338382e706e67)

### 矩阵路径

#### [64. 最小路径和(经典入门)](https://leetcode-cn.com/problems/minimum-path-sum/)

- 辅助空间使用一个**二维数组**或者优化为一个**一维数组**或者直接在**原数组上填充**
- 还可以根据情况选择从前往后填充还是从后往前填充

```java
public int minPathSum(int[][] grid) {

    if(grid == null || grid.length == 0 || grid[0].length == 0) 
        return 0;
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    dp[0] = grid[0][0];
    for(int i = 1; i < n; i++) dp[i] = dp[i - 1] + grid[0][i];

    for(int i = 1; i < m; i++) {
        dp[0] += grid[i][0];
        for(int j = 1; j < n; j++)
            dp[j] = grid[i][j] + Math.min(dp[j - 1], dp[j]);
    }

    return dp[n - 1];
}
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

与上题基本相同

### 数组区间

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

维护一个sum数组，sum[i]表示nums[0: i]的和

#### [*413. 等差数列划分(dp[i]不是最终结果)](https://leetcode-cn.com/problems/arithmetic-slices/)

[1, 2, 3]   dp[3] = 1

[1, 2, 3, 4] dp[4] = dp[3] + 1 // 1代表 1234本身， dp[3]代表 2 3 4和dp[3]一样

最后求和需要将其加起来

```java
public int numberOfArithmeticSlices(int[] A) {

    if(A == null || A.length == 0) return 0;
    int[] dp = new int[A.length];
    for(int i = 2; i < A.length; i++) {
        if(A[i - 1] - A[i] == A[i - 2] - A[i - 1])
            dp[i] = dp[i - 1] + 1;
    }

    int res = 0;
    for(int num: dp)
        res += num;

    return res;
}
```

### 分割整数

#### [343. 整数拆分(需要和之前所有结果进行比较)](https://leetcode-cn.com/problems/integer-break/)

分割尽量多的 3 和 2， 3优先

动态规划，dp[i]表示 i能获得的最大乘积

```java
public int integerBreak(int n) {

    if(n < 2) return 0;
    int[] dp = new int[n + 1];
    for(int i = 2; i < n + 1; i++) {
        int max = -1;
        for(int j = 1; j <= i / 2; j ++) { // 拆分一个j出来
            max = Math.max(max, j * Math.max(i - j, dp[i - j]));
        }
        dp[i] = max;
    }

    return dp[n];
}
```

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

和上题类似

### 最长递增子序列

#### [*300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

动态规划，和数组区间的题类似，时间复杂度
$$
O(n^2)
$$

```java
public int lengthOfLIS(int[] nums) {

    if(nums == null || nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    for(int i = 0; i < nums.length; i++) {
        int max = dp[i];
        for(int j = i - 1; j >= 0; j--) {
            if(nums[j] < nums[i])
                max = Math.max(max, dp[j] + 1);
        }
        dp[i] = max;
    }

    int res = -1;
    for(int num: dp) res = Math.max(res, num);
    return res;
}
```

### 最长公共子序列

#### [1143. 最长公共子序列(二维dp数组)](https://leetcode-cn.com/problems/longest-common-subsequence/)

### 0-1 背包

标准套路：

- 明确 状态和选择
- 明确dp数组的含义
- 根据**选择**思考状态转移方程

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

##### 第一步，明确**状态**和**选择**

类比最经典的0-1背包问题：N个物体，每个物体有重量和价值，背包容量M，求能装物体的最大价值。 

- 状态是指：构成这个问题的一个解（不一定最优）的必备元素：选择了几个物体，他们有各自的重量，重量和不超过M。所以状态为**所选物品**和**背包容量**
- 选择是指，装进背包或者不装进背包
- 到这个问题，问题的一个解（不一定是最优），选了几个字符串，包含若干0和1，0和1的个数不超过m和n。所以状态为 **所选字符串**和**m**和**n**
- 选择是，选择这个字符串或者不选择这个字符串
- 注意到这里其实有三个状态，所选字符串，m, n

```
for 状态1 in 集合
	for 状态2 in 集合
		for ...
			dp[状态1][状态2][...] = 择优(选择1，选择2，...)
```



##### 第二步，明确dp数组的含义

有了状态，结合题目要求（要求最多能组成几个字符串）其实就很好思考dp[i, j, k]表示：j个0，k个1最多能组成几个字符串，字符串是数组中的前i个。然后就是用循环填充整个数组。最后结果为dp[n, m, n]

##### 第三步，根据选择思考状态转移方程

根据选择的定义

- 如果不选 `dp[i, j, k] = dp[i -1, j, k]`
- 如果选了，第i个数有1个0和2个1组成 `dp[i, j, k] = dp[i - 1, j - 1, k - 2] + 1`比较两个结果的大小即可

##### 补充步骤

- 优化存储空间 dp[i]只和dp[i - 1]相关，不需要三维数组，只需要二维即可
- 优化了存储空间就会涉及覆盖时是从左向右还是从右向左，还是用两个数组交替使用，是从左上到右下还是从右下到左上等问题

```java
public int findMaxForm(String[] strs, int m, int n) {

    int[][] dp = new int[m + 1][n + 1];
    for(String str: strs) {
        int[] tmp = count(str);
        for(int i = m; i >= tmp[0]; i--) {
            for(int j = n; j >= tmp[1]; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - tmp[0]][j - tmp[1]] + 1);
            }
        }
    }

    return dp[m][n];
}

private int[] count(String str) {

    int[] res = new int[2];
    for(int i = 0; i < str.length(); i++)
        res[str.charAt(i) - '0'] ++;
    return res;
}
```

#### [*416. 分割等和子集(经典背包问题)](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

- 状态：所选的数字，以及目标和。选择：选择这个数字或者不选这个数字
- dp 题目所求是是否可以选择一些数组合为target, dp[i, j] 表示是否可以从前i个数中选一些，加起来和为j
- 状态转移方程 dp[i, j] = dp[i - 1, j] || dp[i - 1, j - nums[i]]  ,选或者不选这个数字

```java
public boolean canPartition(int[] nums) {

    int sum = 0;
    for(int num: nums) sum += num;
    if(sum % 2 != 0) return false;
    int target = sum / 2;
    boolean[] dp = new boolean[target + 1];
    Arrays.fill(dp, false);
    if(nums[0] <= target) dp[nums[0]] = true;
    dp[0] = true;
    for(int i = 1; i < nums.length; i++) {
        for(int j = target; j >= 0; j--) {
            dp[j] = dp[j] || (j - nums[i] >= 0 && dp[j - nums[i]]);
            if(dp[target]) return true;
        }
    }

    return false;
}
```

#### [*494. 目标和(经典背包问题)](https://leetcode-cn.com/problems/target-sum/)

- 可以优化为一个2行的二维数组
- 思路并不难，但是由于复数以及0的存在，使得需要考虑的条件很多
- dp[i, j]表示 前 i个数  组成j 有几种可能

```java
public int findTargetSumWays(int[] nums, int S) {

    int sum = 0;
    for(int num: nums) sum += num;
    S = Math.abs(S); // S可能为负 但是对称，所以转化为正
    if(S > sum) return 0;
    int[][] dp = new int[nums.length][sum + 1];
    if(nums[0] == 0) dp[0][nums[0]] = 2; // +0 -0 都是0
    else dp[0][nums[0]] = 1;
    for(int i = 1; i < nums.length; i++) { // 第几个数字
        int num = nums[i];
        for(int j = 0; j < sum + 1; j++) { // 目标和为几
            int l = dp[i - 1][Math.abs(j - num)]; // num 前面加正号
            int r = (j + num) <= sum ? dp[i-1][j + num]: 0; // num加负号
            dp[i][j] = l + r;
        }
    }

    return dp[nums.length - 1][S]; // 前面保证过S在小于等于sum 且为正
}
```

#### [322. 零钱兑换(完全背包问题)](https://leetcode-cn.com/problems/coin-change/)

- 所求，怎样能使硬币个数最少

- 状态 ：amount， 所选的硬币（硬币个数无限，所以是完全背包问题）
- 选择：从coins中选择一种硬币
- dp[i, j] 使用前i种硬币，凑成j所需最少硬币个数 
- dp[i, j] = min(dp[i - 1, j - coins[i]] + 1, dp[i - 1, j]) 对应是否装进背包
- **注意**：刚开始认为 dp[i, j] = min(装0个硬币i， 装1个硬币i，装2个硬币i...)， 其实 j会遍历0-amount，并且从左往右更新，所以到j = 2*coin时，前边 j = coin已经更新了最小值，所以其实每次只需要比较选择1个和选择0个两种情况
- 可以压缩为一维数组

```java
// 套路解法
public int coinChange(int[] coins, int amount) {

    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    for(int i = 0; i < coins.length; i++) {
        int coin = coins[i];
        for(int j = coin; j <= amount; j ++) {
            dp[j] = Math.min(dp[j], dp[j - coin] + 1);
        }
    }

    return dp[amount] == (amount + 1) ? -1 : dp[amount];
}
// 自己的另一个思路
public int coinChange(int[] coins, int amount) {

    int[] dp = new int[amount + 1];
    dp[0] = 0;
    for(int i = 1; i <= amount; i++) {
        int min = i + 1;
        for(int j = 0; j < coins.length; j ++) {
            int coin = coins[j];
            if(coin <= i) {
                if(dp[i - coin] != -1)
                    min = Math.min(min, dp[i - coin] + 1);
            }
        }
        if(min == i + 1) dp[i] = -1;
        else dp[i] = min;
    }

    return dp[amount];
}
```

#### [518. 零钱兑换 II(完全背包问题)](https://leetcode-cn.com/problems/coin-change-2/)

- 所求：和为sum的硬币组合方法
- 状态： 背包容量和所选物品。选择：是否装进背包
- 本题状态：目标和，所选硬币。本题选择：选择一个coin装进背包
- dp[i, j] 选择前i种硬币凑成j 有多少种可能
- dp[i, j] = `dp[i - 1, j]` + `dp[i - 1, j - coins[i]]`  分别对应 硬币是否装进背包
- 由于只和上一行有关，可以压缩

```java
public int change(int amount, int[] coins) {

    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for(int i = 0; i < coins.length; i++) { // 前几种硬币
        int coin = coins[i];
        for(int j = coin; j <= amount; j++) // 目标和
            dp[j] += dp[j - coin];
    }

    return dp[amount];
}
```

