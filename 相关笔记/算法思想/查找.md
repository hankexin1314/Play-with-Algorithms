## 二分查找

对于二分查找，一些经验：

- 对于退出条件 `l < r`最后二者相等
- 对于推出条件`l <= r`，最后r小于l，相差1

#### [*69. x 的平方根(经典入门)](https://leetcode-cn.com/problems/sqrtx/)

题目看起来简单，但是坑很多：

- 溢出问题，因为不能使用`sqrt(x)`作为右边界，所以直接计算`mid * mid`可能越界，两个解决方案：使用long，使用除法
- 使用`<=`，最后返回`r`，因为要找一个不超过sqrt(x)的数，循环的最后，l和r相邻，l大于r，r^2<target, l^2>target
- l = mid + 1，如果不这样会陷入无限循环

```java
    public int mySqrt(int x) {
        
        if(x <= 1) return x;
        int l = 1, r = x;
        while(l <= r) {
            int mid = (r - l) / 2 + l;
            int sqrt = x / mid;
            if(mid == sqrt) return mid;
            else if(mid < sqrt) l = mid + 1;
            else r = mid - 1;
        }

        return r;
    }
```

#### [*剑指 Offer 11. 旋转数组的最小数字(简单的变种)](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

最后一种情况的解释:

- 二分法实质上也是**缩小搜索范围**
- == 的情况下，因为在l < r时，mid肯定不是r对应的数，既然二者相等，去掉r对结果也不会有影响，所以这样做

```java
public int minNumberInRotateArray(int [] array) {

    if(array == null || array.length == 0) return 0;
    int l = 0, r = array.length - 1;
    while(l < r) {
        int mid = (r - l) / 2 + l;
        int num = array[mid];
        if(num > array[r]) l = mid + 1;
        else if(num < array[r]) r = mid;
        else r--; // 不太好解释
    }

    return array[l];
}
```

#### [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

- 循环结束后 l > r，所以需要返回l

```java
public char nextGreatestLetter(char[] letters, char target) {

    if(letters == null || letters.length == 0)
        throw new IllegalStateException("no solution");
    if(target >= letters[letters.length - 1]) return letters[0];

    int l = 0, r = letters.length - 1;
    while(l <= r) {
        int mid = (r - l) / 2 + l;
        if(letters[mid] > target) 
            r = mid - 1;
        else
            l = mid + 1;
    }

    return letters[l];
}
```

#### [*540. 有序数组中的单一元素(复杂的整合)](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

- 二分查找和index相结合，搞清楚index和相邻数的关系

```java
public int singleNonDuplicate(int[] nums) {

    if(nums == null || nums.length == 0) 
        throw new IllegalStateException("no solution");

    int l = 0, r = nums.length - 1;
    while(l < r) {
        int mid = (r - l) / 2 + l;
        if(nums[mid] == nums[mid - 1]) {
            if(mid % 2 == 0)
                r = mid - 2;
            else
                l = mid + 1;
        }
        else if(nums[mid] == nums[mid + 1]) {
            if(mid % 2 == 0)
                l = mid + 2;
            else
                r = mid - 1;
        }
        else 
            return nums[mid];
    }
    return nums[l];
}
```



## 分治

## 回溯



#### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

- 左上角，右下角尝试后不行，要勇于尝试左下和右上角。

```java
public boolean Find(int target, int [][] array) {

    if(array == null)
        return false;
    int m = array.length, n = array[0].length;
    int x = 0, y = n - 1;
    while(x < m && y >= 0) {
        int num = array[x][y];
        if(num == target) return true;
        else if(num > target) y --;
        else x ++;
    }

    return false;
}
```

